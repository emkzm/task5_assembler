.model small
.stack 100h
.186
.data
;Определение переменных:

;row – строка, в которой находится курсор, начальное значение равно 4
row db 4
;col – столбец, в котором находится курсор, начальное значение равно 24
col db 24
;mode – номер режима, начальное значение не определено (равно ?)
mode db ?
;char_ctr – счетчик ASCII-символов, начальное значение равно 0
char_ctr db 0

top_left_corner dw 344 ; 04:24 = 4*80 + 24
bottm_right_corner dw 1574 ; 19:54 = 19*80 + 54

.code
start:
mov ax,@data
mov ds,ax
call B10MODE ; установка видео режима
call C10CLEAR ; очистка экрана

no_lsymbol_and_no_lim: 
call D10CURSOR ; устанока курсора
cmp char_ctr, 255 ; последний символ ?
je last_symbol  

inc char_ctr ; увеличить значение счетчика аски символов на 1
add col, 2 ; увеличить значение столбца на 2
cmp col, 56 ; достигнет ли конец столбца 56 = 24 + 16 * 2

jne no_lsymbol_and_no_lim 
; переход к новой строке 
inc row; увеличим значение row на 1
mov col, 24; и устанавливаем значение col на 24 (дефолт)
jmp no_lsymbol_and_no_lim;

last_symbol:
mov ah, 10h ; Запрос на получение символа с клавиатуры
int 16h

mov ah, 00h ; Возврат исходного графического режима
mov al, mode
int 10h

mov ax,4C00h       ;Завершение программы
int 21h

;Определение подпрограмм

B10MODE proc       ;Получение/установка видеорежима
mov ah, 0fh ; Получаем текущий режим в регистре AL: в регистр AH заносим значение 0Fh после чего вызывается прерывание 10h.
int 10h 
mov mode, al ; Сохраняем номер текущего режима: заносим в mode содержимое регистра AL.
mov ah, 00h ; Переводим экран в текстовый режим с номером 03: в регистр AH помещается значение 00h,
mov al, 03h ;  в регистр AL – номер режима 03,
int 10h ;  послечего вызывается прерывание 10h.
ret ; Выполняем возврат из подпрограммы в точку вызова.
B10MODE endp

C10CLEAR proc      ;Очистка экрана
pusha ; Помещаем в стек все регистры общего назначения.
mov ah, 06h ; Прокручиваем вверх весь экран целиком (см. функция 06h).
int 10h
; Создаем окно с 16 строками и 16 столбцами: 
mov ah, 06h ; в регистр AH заносим значение 06h
mov al, 10h ; в регистр AL – число строк 10h
mov bh, 00101111b; в регистр BH значение атрибута - зеленый(0010) фон, белые символы(1111)  
mov cx, top_left_corner ; в регистр CX – координаты левого верхнего угла 04:24
mov dx, bottm_right_corner ; регистр DX – координаты правого нижнего угла  
int 10h ; после чего вызывается прерывание 10h.
popa ; Загружаем из стека все регистры общего назначения
ret ; Выполняем возврат из подпрограммы в точку вызова
C10CLEAR endp

D10CURSOR proc     ;Установка курсора
pusha ; Помещаем в стек все регистры общего назначения.
; Устанавливаем курсор:
mov ah, 02h; в регистр AH заносим значение 02h
mov bh, 0; в регистр BH – номер страницы 0
mov dh, row; в регистр DH – значение строки row
mov dl, col; в регистр DL – значение столбца col
int 10h; после чего вызывается прерывание 10h
popa ; Загружаем из стека все регистры общего назначения
ret ; Выполняем возврат из подпрограммы в точку вызова
D10CURSOR endp

E10DISPLAY proc    ;Вывод символа на экран
pusha; Помещаем в стек все регистры общего назначения
; Выводим символ с установленным атрибутом на экран:
mov ah, 0Ah; в регистр AH заносим значение 0Ah
mov al, char_ctr; в регистр AL – ASCII -код символа char_ctr
mov bh, 0; в регистр BH – номер страницы 0
mov cx, 1; в регистр CX – число символов 1
int 10h; после чего вызывается прерывание 10h
popa; Загружаем из стека все регистры общего назначения
ret ; Выполняем возврат из подпрограммы в точку вызова
E10DISPLAY endp

end start          ;Конец программы